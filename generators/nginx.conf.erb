    <% if (is_using('unicorn',:app_server) || is_using('puma',:app_server))%>
    upstream <%= application %>_<%= rails_env %>_app_server {
        server unix:<%= File.join("#{shared_path}","sockets", "puma.sock") %> fail_timeout=0;
    }
    <% end %>

    # <%= application %> <%= rails_env %> Server
    server {
        listen <%= application_port %>;
        <% if is_using('passenger',:app_server) %>
        rails_env <%= rails_env %>;
        passenger_enabled on;
        <% end %>
        client_max_body_size 500M;
        server_name <%= server_names %>;

        # ~2 seconds is often enough for most folks to parse HTML/CSS and
        # retrieve needed images/icons/frames, connections are cheap in
        # nginx so increasing this is generally safe...
        keepalive_timeout 5;

        # path for static files
        root <%= deploy_to %>/current/public;
        access_log /var/log/nginx/<%= application %>/<%= rails_env %>.access.log;
        error_log  /var/log/nginx/<%= application %>/<%= rails_env %>.error.log info;

        # this rewrites all the requests to the maintenance.html
        # page if it exists in the doc root. This is for capistrano's
        # disable web task
        if (-f $document_root/system/maintenance.html) {
          rewrite  ^(.*)$  /system/maintenance.html last;
          break;
        }

        location / {
        <% if nginx_simple_auth %>
          auth_basic "<%= nginx_simple_auth_message %>";
          auth_basic_user_file <%= File.join("#{shared_path}", "config", ".htpasswd") %>;
        <% end %>
        <% if is_using('passenger',:app_server) %>
          rails_env <%= rails_env %>;
          passenger_enabled on;
        <% end %>

          proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
          proxy_set_header Host $http_host;

          # if the request is for a static resource, nginx should serve it directly
          # and add a far future expires header to it, making the browser
          # cache the resource and navigate faster over the website.
          location ~ ^/(assets)/.+-([0-9a-zA-Z])+\. {
            gzip_static on;
            expires max;
            add_header Cache-Control public;
          }        

          # Serve images outside the asset path
          # Now this supposedly should work as it gets the filenames with querystrings that Rails provides.
          # BUT there's a chance it could break the ajax calls.
          location ~* \.(ico|css|gif|jpe?g|png)(\?[0-9]+)?$ {
             expires max;
          }

          # Serve javascript outside the asset path
          location ~ ^/javascripts/.*\.js(\?[0-9]+)?$ {
             expires max;
          }

          # If the file exists as a static file serve it directly without
          # running all the other rewite tests on it
          if (-f $request_filename) {
            break;
          }

          # check for index.html for directory index
          # if its there on the filesystem then rewite
          # the url to add /index.html to the end of it
          # and then break to send it to the next config rules.
          if (-f $request_filename/index.html) {
            rewrite (.*) $1/index.html break;
          }

          # this is the meat of the rails page caching config
          # it adds .html to the end of the url and then checks
          # the filesystem for that file. If it exists, then we
          # rewite the url to have explicit .html on the end
          # and then send it on its way to the next config rule.
          # if there is no file on the fs then it sets all the
          # necessary headers and proxies to our upstream mongrels
          if (-f $request_filename.html) {
            rewrite (.*) $1.html break;
          }

          <% if (is_using('unicorn',:app_server) || is_using('puma',:app_server))%>
          if (!-f $request_filename) {
            proxy_pass http://<%= application %>_<%= rails_env %>_app_server;
            break;
          }
          <% end %>
        }

        # Rails error pages
        error_page 500 502 503 504 /500.html;
        location = /500.html {
          root <%= deploy_to %>/current/public;
        }
    }

    <% if application_uses_ssl %>

    <% if (is_using('unicorn',:app_server) || is_using('puma',:app_server))%>
    upstream <%= application %>_<%= rails_env %>_app_ssl {
      server unix:<%= File.join(sockets_path,"#{app_server}","#{application}_#{rails_env}.sock") %> fail_timeout=0;
    }
    <% end %>

    # This server is setup for ssl. Uncomment if
    # you are using ssl as well as port 80.
    server {
      listen <%= application_port_ssl%>;
      server_name <%= server_names %>;
      <% if is_using('passenger',:app_server) %>
      rails_env <%= rails_env %>;
      passenger_enabled on;
      <% end %>
      ssl                     on;
      ssl_certificate         /etc/ssl/certs/server.crt;
      ssl_certificate_key     /etc/ssl/private/server.key;
      ssl_session_timeout     5m;
      client_max_body_size    50M;

      root <%= deploy_to %>/current/public;
      access_log /var/log/nginx/<%= application %>_<%= rails_env %>.access.log main;
      error_log  /var/log/nginx/<%= application %>_<%= rails_env %>.error.log info;

      # this rewrites all the requests to the maintenance.html
      # page if it exists in the doc root. This is for capistrano's
      # disable web task
      if (-f $document_root/system/maintenance.html) {
        rewrite  ^(.*)$  /system/maintenance.html last;
        break;
      }

      location / {
      <% if nginx_simple_auth %>
        auth_basic "<%= nginx_simple_auth_message %>";
        auth_basic_user_file <%= File.join("#{shared_path}", "config", ".htpasswd") %>;
      <% end %>
      <% if is_using('passenger',:app_server) %>
        rails_env <%= rails_env %>;
        passenger_enabled on;
      <% end %>

        # needed to forward user's IP address to rails
        proxy_set_header  X-Real-IP  $remote_addr;

        # needed for HTTPS
        proxy_set_header X_FORWARDED_PROTO https;

        proxy_set_header  X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header Host $http_host;
        proxy_redirect off;
        proxy_max_temp_file_size 0;


        # if the request is for a static resource, nginx should serve it directly
        # and add a far future expires header to it, making the browser
        # cache the resource and navigate faster over the website.
        location ~ ^/(assets)/.+-([0-9a-zA-Z])+\. {
          gzip_static on;
          expires max;
          add_header Cache-Control public;
        }        

        # Serve images outside the asset path
        # Now this supposedly should work as it gets the filenames with querystrings that Rails provides.
        # BUT there's a chance it could break the ajax calls.
        location ~* \.(ico|css|gif|jpe?g|png)(\?[0-9]+)?$ {
           expires max;
        }

        # Serve javascript outside the asset path
        location ~ ^/javascripts/.*\.js(\?[0-9]+)?$ {
           expires max;
        }

        # If the file exists as a static file serve it directly without
        # running all the other rewite tests on it
        if (-f $request_filename) {
          break;
        }

        # check for index.html for directory index
        # if its there on the filesystem then rewite
        # the url to add /index.html to the end of it
        # and then break to send it to the next config rules.
        if (-f $request_filename/index.html) {
          rewrite (.*) $1/index.html break;
        }

        # this is the meat of the rails page caching config
        # it adds .html to the end of the url and then checks
        # the filesystem for that file. If it exists, then we
        # rewite the url to have explicit .html on the end
        # and then send it on its way to the next config rule.
        # if there is no file on the fs then it sets all the
        # necessary headers and proxies to our upstream mongrels
        if (-f $request_filename.html) {
          rewrite (.*) $1.html break;
        }

        <% if (is_using('unicorn',:app_server) || is_using('puma',:app_server))%>
        if (!-f $request_filename) {
          proxy_pass http://<%= application %>_<%= rails_env %>_app_ssl;
          break;
        }
        <% end %>
      }

      error_page   500 502 503 504  /500.html;
      location = /500.html {
        root   <%= deploy_to %>/current/public;
      }
    }
    <% end %>

